import { ImageBlock, VideoBlock, DocumentBlock } from './media.js';
/**
 * A message in a conversation between user and assistant.
 * Each message has a role (user or assistant) and an array of content blocks.
 */
export class Message {
    /**
     * Discriminator for message type.
     */
    type = 'message';
    /**
     * The role of the message sender.
     */
    role;
    /**
     * Array of content blocks that make up this message.
     */
    content;
    constructor(data) {
        this.role = data.role;
        this.content = data.content;
    }
    /**
     * Creates a Message instance from MessageData.
     */
    static fromMessageData(data) {
        const contentBlocks = data.content.map(contentBlockFromData);
        return new Message({
            role: data.role,
            content: contentBlocks,
        });
    }
}
/**
 * Text content block within a message.
 */
export class TextBlock {
    /**
     * Discriminator for text content.
     */
    type = 'textBlock';
    /**
     * Plain text content.
     */
    text;
    constructor(data) {
        this.text = data;
    }
}
/**
 * Tool use content block.
 */
export class ToolUseBlock {
    /**
     * Discriminator for tool use content.
     */
    type = 'toolUseBlock';
    /**
     * The name of the tool to execute.
     */
    name;
    /**
     * Unique identifier for this tool use instance.
     */
    toolUseId;
    /**
     * The input parameters for the tool.
     * This can be any JSON-serializable value.
     */
    input;
    constructor(data) {
        this.name = data.name;
        this.toolUseId = data.toolUseId;
        this.input = data.input;
    }
}
/**
 * Tool result content block.
 */
export class ToolResultBlock {
    /**
     * Discriminator for tool result content.
     */
    type = 'toolResultBlock';
    /**
     * The ID of the tool use that this result corresponds to.
     */
    toolUseId;
    /**
     * Status of the tool execution.
     */
    status;
    /**
     * The content returned by the tool.
     */
    content;
    /**
     * The original error object when status is 'error'.
     * Available for inspection by hooks, error handlers, and event loop.
     * Tools must wrap non-Error thrown values into Error objects.
     */
    error;
    constructor(data) {
        this.toolUseId = data.toolUseId;
        this.status = data.status;
        this.content = data.content;
        if (data.error !== undefined) {
            this.error = data.error;
        }
    }
}
/**
 * Reasoning content block within a message.
 */
export class ReasoningBlock {
    /**
     * Discriminator for reasoning content.
     */
    type = 'reasoningBlock';
    /**
     * The text content of the reasoning process.
     */
    text;
    /**
     * A cryptographic signature for verification purposes.
     */
    signature;
    /**
     * The redacted content of the reasoning process.
     */
    redactedContent;
    constructor(data) {
        if (data.text !== undefined) {
            this.text = data.text;
        }
        if (data.signature !== undefined) {
            this.signature = data.signature;
        }
        if (data.redactedContent !== undefined) {
            this.redactedContent = data.redactedContent;
        }
    }
}
/**
 * Cache point block for prompt caching.
 * Marks a position in a message or system prompt where caching should occur.
 */
export class CachePointBlock {
    /**
     * Discriminator for cache point.
     */
    type = 'cachePointBlock';
    /**
     * The cache type. Currently only 'default' is supported.
     */
    cacheType;
    constructor(data) {
        this.cacheType = data.cacheType;
    }
}
/**
 * JSON content block within a message.
 * Used for structured data returned from tools or model responses.
 */
export class JsonBlock {
    /**
     * Discriminator for JSON content.
     */
    type = 'jsonBlock';
    /**
     * Structured JSON data.
     */
    json;
    constructor(data) {
        this.json = data.json;
    }
}
/**
 * Converts SystemPromptData to SystemPrompt by converting data blocks to class instances.
 * If already in SystemPrompt format (class instances), returns as-is.
 *
 * @param data - System prompt data to convert
 * @returns SystemPrompt with class-based content blocks
 */
export function systemPromptFromData(data) {
    if (typeof data === 'string') {
        return data;
    }
    // Convert data format to class instances
    return data.map((block) => {
        if ('type' in block) {
            return block;
        }
        else if ('cachePoint' in block) {
            return new CachePointBlock(block.cachePoint);
        }
        else if ('guardContent' in block) {
            return new GuardContentBlock(block.guardContent);
        }
        else if ('text' in block) {
            return new TextBlock(block.text);
        }
        else {
            throw new Error('Unknown SystemContentBlockData type');
        }
    });
}
/**
 * Guard content block for guardrail evaluation.
 * Marks content that should be evaluated by guardrails for safety, grounding, or other policies.
 * Can be used in both message content and system prompts.
 */
export class GuardContentBlock {
    /**
     * Discriminator for guard content.
     */
    type = 'guardContentBlock';
    /**
     * Text content with evaluation qualifiers.
     */
    text;
    /**
     * Image content with evaluation qualifiers.
     */
    image;
    constructor(data) {
        if (!data.text && !data.image) {
            throw new Error('GuardContentBlock must have either text or image content');
        }
        if (data.text && data.image) {
            throw new Error('GuardContentBlock cannot have both text and image content');
        }
        if (data.text) {
            this.text = data.text;
        }
        if (data.image) {
            this.image = data.image;
        }
    }
}
/**
 * Converts ContentBlockData to a ContentBlock instance.
 * Handles all content block types including text, tool use/result, reasoning, cache points, guard content, and media blocks.
 *
 * @param data - The content block data to convert
 * @returns A ContentBlock instance of the appropriate type
 * @throws Error if the content block type is unknown
 */
export function contentBlockFromData(data) {
    if ('text' in data) {
        return new TextBlock(data.text);
    }
    else if ('toolUse' in data) {
        return new ToolUseBlock(data.toolUse);
    }
    else if ('toolResult' in data) {
        return new ToolResultBlock({
            toolUseId: data.toolResult.toolUseId,
            status: data.toolResult.status,
            content: data.toolResult.content.map((contentItem) => {
                if ('text' in contentItem) {
                    return new TextBlock(contentItem.text);
                }
                else if ('json' in contentItem) {
                    return new JsonBlock(contentItem);
                }
                else {
                    throw new Error('Unknown ToolResultContentData type');
                }
            }),
        });
    }
    else if ('reasoning' in data) {
        return new ReasoningBlock(data.reasoning);
    }
    else if ('cachePoint' in data) {
        return new CachePointBlock(data.cachePoint);
    }
    else if ('guardContent' in data) {
        return new GuardContentBlock(data.guardContent);
    }
    else if ('image' in data) {
        return new ImageBlock(data.image);
    }
    else if ('video' in data) {
        return new VideoBlock(data.video);
    }
    else if ('document' in data) {
        return new DocumentBlock(data.document);
    }
    else {
        throw new Error('Unknown ContentBlockData type');
    }
}
//# sourceMappingURL=messages.js.map