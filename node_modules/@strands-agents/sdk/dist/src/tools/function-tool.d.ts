import { Tool } from './tool.js';
import type { ToolContext } from './tool.js';
import { ToolStreamEvent } from './tool.js';
import type { ToolSpec } from './types.js';
import type { JSONSchema, JSONValue } from '../types/json.js';
import { ToolResultBlock } from '../types/messages.js';
/**
 * Callback function for FunctionTool implementations.
 * The callback can return values in multiple ways, and FunctionTool handles the conversion to ToolResultBlock.
 *
 * @param input - The input parameters conforming to the tool's inputSchema
 * @param toolContext - The tool execution context with invocation state
 * @returns Can return:
 *   - AsyncGenerator: Each yielded value becomes a ToolStreamEvent, final value wrapped in ToolResultBlock
 *   - Promise: Resolved value is wrapped in ToolResultBlock
 *   - Synchronous value: Value is wrapped in ToolResultBlock
 *   - If an error is thrown, it's handled and returned as an error ToolResultBlock
 *
 * @example
 * ```typescript
 * // Async generator example
 * async function* calculator(input: unknown, context: ToolContext) {
 *   yield 'Calculating...'
 *   const result = input.a + input.b
 *   yield `Result: ${result}`
 *   return result
 * }
 *
 * // Promise example
 * async function fetchData(input: unknown, context: ToolContext) {
 *   const response = await fetch(input.url)
 *   return await response.json()
 * }
 *
 * // Synchronous example
 * function multiply(input: unknown, context: ToolContext) {
 *   return input.a * input.b
 * }
 * ```
 */
export type FunctionToolCallback = (input: unknown, toolContext: ToolContext) => AsyncGenerator<JSONValue, JSONValue, never> | Promise<JSONValue> | JSONValue;
/**
 * Configuration options for creating a FunctionTool.
 */
export interface FunctionToolConfig {
    /** The unique name of the tool */
    name: string;
    /** Human-readable description of the tool's purpose */
    description: string;
    /** JSON Schema defining the expected input structure. If omitted, defaults to an empty object schema. */
    inputSchema?: JSONSchema;
    /** Function that implements the tool logic */
    callback: FunctionToolCallback;
}
/**
 * A Tool implementation that wraps a callback function and handles all ToolResultBlock conversion.
 *
 * FunctionTool allows creating tools from existing functions without needing to manually
 * handle ToolResultBlock formatting or error handling. It supports multiple callback patterns:
 * - Async generators for streaming responses
 * - Promises for async operations
 * - Synchronous functions for immediate results
 *
 * All return values are automatically wrapped in ToolResultBlock, and errors are caught and
 * returned as error ToolResultBlocks.
 *
 * @example
 * ```typescript
 * // Create a tool with streaming
 * const streamingTool = new FunctionTool({
 *   name: 'processor',
 *   description: 'Processes data with progress updates',
 *   inputSchema: { type: 'object', properties: { data: { type: 'string' } } },
 *   callback: async function* (input: any) {
 *     yield 'Starting processing...'
 *     // Do some work
 *     yield 'Halfway done...'
 *     // More work
 *     return 'Processing complete!'
 *   }
 * })
 * ```
 */
export declare class FunctionTool extends Tool {
    /**
     * The unique name of the tool.
     */
    readonly name: string;
    /**
     * Human-readable description of what the tool does.
     */
    readonly description: string;
    /**
     * OpenAPI JSON specification for the tool.
     */
    readonly toolSpec: ToolSpec;
    /**
     * The callback function that implements the tool's logic.
     */
    private readonly _callback;
    /**
     * Creates a new FunctionTool instance.
     *
     * @param config - Configuration object for the tool
     *
     * @example
     * ```typescript
     * // Tool with input schema
     * const greetTool = new FunctionTool({
     *   name: 'greeter',
     *   description: 'Greets a person by name',
     *   inputSchema: {
     *     type: 'object',
     *     properties: { name: { type: 'string' } },
     *     required: ['name']
     *   },
     *   callback: (input: any) => `Hello, ${input.name}!`
     * })
     *
     * // Tool without input (no parameters)
     * const statusTool = new FunctionTool({
     *   name: 'getStatus',
     *   description: 'Gets system status',
     *   callback: () => ({ status: 'operational' })
     * })
     * ```
     */
    constructor(config: FunctionToolConfig);
    /**
     * Executes the tool with streaming support.
     * Handles all callback patterns (async generator, promise, sync) and converts results to ToolResultBlock.
     *
     * @param toolContext - Context information including the tool use request and invocation state
     * @returns Async generator that yields ToolStreamEvents and returns a ToolResultBlock
     */
    stream(toolContext: ToolContext): AsyncGenerator<ToolStreamEvent, ToolResultBlock, unknown>;
    /**
     * Wraps a value in a ToolResultBlock with success status.
     *
     * Due to AWS Bedrock limitations (only accepts objects as JSON content), the following
     * rules are applied:
     * - Strings → TextBlock
     * - Numbers, Booleans → TextBlock (converted to string)
     * - null, undefined → TextBlock (special string representation)
     * - Objects → JsonBlock (with deep copy)
     * - Arrays → JsonBlock wrapped in \{ $value: array \} (with deep copy)
     *
     * @param value - The value to wrap (can be any type)
     * @param toolUseId - The tool use ID for the ToolResultBlock
     * @returns A ToolResultBlock containing the value
     */
    private _wrapInToolResult;
}
//# sourceMappingURL=function-tool.d.ts.map