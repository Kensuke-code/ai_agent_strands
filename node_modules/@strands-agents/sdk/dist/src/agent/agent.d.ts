import { AgentResult, type AgentStreamEvent, type ContentBlock, type ContentBlockData, type JSONValue, McpClient, Message, type MessageData, type SystemPrompt, type SystemPromptData, type Tool } from '../index.js';
import type { BaseModelConfig, Model } from '../models/model.js';
import { ToolRegistry } from '../registry/tool-registry.js';
import { AgentState } from './state.js';
import type { AgentData } from '../types/agent.js';
import type { HookProvider } from '../hooks/types.js';
import { HookRegistryImplementation } from '../hooks/registry.js';
/**
 * Recursive type definition for nested tool arrays.
 * Allows tools to be organized in nested arrays of any depth.
 */
export type ToolList = (Tool | McpClient | ToolList)[];
/**
 * Configuration object for creating a new Agent.
 */
export type AgentConfig = {
    /**
     * The model instance that the agent will use to make decisions.
     * Accepts either a Model instance or a string representing a Bedrock model ID.
     * When a string is provided, it will be used to create a BedrockModel instance.
     *
     * @example
     * ```typescript
     * // Using a string model ID (creates BedrockModel)
     * const agent = new Agent({
     *   model: 'anthropic.claude-3-5-sonnet-20240620-v1:0'
     * })
     *
     * // Using an explicit BedrockModel instance with configuration
     * const agent = new Agent({
     *   model: new BedrockModel({
     *     modelId: 'anthropic.claude-3-5-sonnet-20240620-v1:0',
     *     temperature: 0.7,
     *     maxTokens: 2048
     *   })
     * })
     * ```
     */
    model?: Model<BaseModelConfig> | string;
    /** An initial set of messages to seed the agent's conversation history. */
    messages?: Message[] | MessageData[];
    /**
     * An initial set of tools to register with the agent.
     * Accepts nested arrays of tools at any depth, which will be flattened automatically.
     */
    tools?: ToolList;
    /**
     * A system prompt which guides model behavior.
     */
    systemPrompt?: SystemPrompt | SystemPromptData;
    /** Optional initial state values for the agent. */
    state?: Record<string, JSONValue>;
    /**
     * Enable automatic printing of agent output to console.
     * When true, prints text generation, reasoning, and tool usage as they occur.
     * Defaults to true.
     */
    printer?: boolean;
    /**
     * Conversation manager for handling message history and context overflow.
     * Defaults to SlidingWindowConversationManager with windowSize of 40.
     */
    conversationManager?: HookProvider;
    /**
     * Hook providers to register with the agent.
     * Hooks enable observing and extending agent behavior.
     */
    hooks?: HookProvider[];
};
/**
 * Arguments for invoking an agent.
 *
 * Supports multiple input formats:
 * - `string` - User text input (wrapped in TextBlock, creates user Message)
 * - `ContentBlock[]` | `ContentBlockData[]` - Array of content blocks (creates single user Message)
 * - `Message[]` | `MessageData[]` - Array of messages (appends all to conversation)
 */
export type InvokeArgs = string | ContentBlock[] | ContentBlockData[] | Message[] | MessageData[];
/**
 * Orchestrates the interaction between a model, a set of tools, and MCP clients.
 * The Agent is responsible for managing the lifecycle of tools and clients
 * and invoking the core decision-making loop.
 */
export declare class Agent implements AgentData {
    /**
     * The conversation history of messages between user and assistant.
     */
    readonly messages: Message[];
    /**
     * Agent state storage accessible to tools and application logic.
     * State is not passed to the model during inference.
     */
    readonly state: AgentState;
    /**
     * Conversation manager for handling message history and context overflow.
     */
    readonly conversationManager: HookProvider;
    /**
     * Hook registry for managing event callbacks.
     * Hooks enable observing and extending agent behavior.
     */
    readonly hooks: HookRegistryImplementation;
    /**
     * The model provider used by the agent for inference.
     */
    model: Model;
    /**
     * The system prompt to pass to the model provider.
     */
    systemPrompt?: SystemPrompt;
    private _toolRegistry;
    private _mcpClients;
    private _initialized;
    private _isInvoking;
    private _printer?;
    /**
     * Creates an instance of the Agent.
     * @param config - The configuration for the agent.
     */
    constructor(config?: AgentConfig);
    initialize(): Promise<void>;
    /**
     * Acquires a lock to prevent concurrent invocations.
     * Returns a Disposable that releases the lock when disposed.
     */
    private acquireLock;
    /**
     * The tools this agent can use.
     */
    get tools(): Tool[];
    /**
     * The tool registry for managing the agent's tools.
     */
    get toolRegistry(): ToolRegistry;
    /**
     * Invokes the agent and returns the final result.
     *
     * This is a convenience method that consumes the stream() method and returns
     * only the final AgentResult. Use stream() if you need access to intermediate
     * streaming events.
     *
     * @param args - Arguments for invoking the agent
     * @returns Promise that resolves to the final AgentResult
     *
     * @example
     * ```typescript
     * const agent = new Agent({ model, tools })
     * const result = await agent.invoke('What is 2 + 2?')
     * console.log(result.lastMessage) // Agent's response
     * ```
     */
    invoke(args: InvokeArgs): Promise<AgentResult>;
    /**
     * Streams the agent execution, yielding events and returning the final result.
     *
     * The agent loop manages the conversation flow by:
     * 1. Streaming model responses and yielding all events
     * 2. Executing tools when the model requests them
     * 3. Continuing the loop until the model completes without tool use
     *
     * Use this method when you need access to intermediate streaming events.
     * For simple request/response without streaming, use invoke() instead.
     *
     * An explicit goal of this method is to always leave the message array in a way that
     * the agent can be reinvoked with a user prompt after this method completes. To that end
     * assistant messages containing tool uses are only added after tool execution succeeds
     * with valid toolResponses
     *
     * @param args - Arguments for invoking the agent
     * @returns Async generator that yields AgentStreamEvent objects and returns AgentResult
     *
     * @example
     * ```typescript
     * const agent = new Agent({ model, tools })
     *
     * for await (const event of agent.stream('Hello')) {
     *   console.log('Event:', event.type)
     * }
     * // Messages array is mutated in place and contains the full conversation
     * ```
     */
    stream(args: InvokeArgs): AsyncGenerator<AgentStreamEvent, AgentResult, undefined>;
    /**
     * Internal implementation of the agent streaming logic.
     * Separated to centralize printer event processing in the public stream method.
     *
     * @param args - Arguments for invoking the agent
     * @returns Async generator that yields AgentStreamEvent objects and returns AgentResult
     */
    private _stream;
    /**
     * Normalizes agent invocation input into an array of messages to append.
     *
     * @param args - Optional arguments for invoking the model
     * @returns Array of messages to append to the conversation
     */
    private _normalizeInput;
    /**
     * Invokes the model provider and streams all events.
     *
     * @param args - Optional arguments for invoking the model
     * @returns Object containing the assistant message and stop reason
     */
    private invokeModel;
    /**
     * Streams events from the model and fires ModelStreamEventHook for each event.
     *
     * @param messages - Messages to send to the model
     * @param streamOptions - Options for streaming
     * @returns Object containing the assistant message and stop reason
     */
    private _streamFromModel;
    /**
     * Executes tools sequentially and streams all tool events.
     *
     * @param assistantMessage - The assistant message containing tool use blocks
     * @param toolRegistry - Registry containing available tools
     * @returns User message containing tool results
     */
    private executeTools;
    /**
     * Executes a single tool and returns the result.
     * If the tool is not found or fails to return a result, returns an error ToolResult
     * instead of throwing an exception. This allows the agent loop to continue and
     * let the model handle the error gracefully.
     *
     * @param toolUseBlock - Tool use block to execute
     * @param toolRegistry - Registry containing available tools
     * @returns Tool result block
     */
    private executeTool;
    /**
     * Appends a message to the conversation history, invokes MessageAddedEvent hook,
     * and returns the event for yielding.
     *
     * @param message - The message to append
     * @returns MessageAddedEvent to be yielded (hook already invoked)
     */
    private _appendMessage;
}
//# sourceMappingURL=agent.d.ts.map